# -*- coding: utf-8 -*-
"""FINE_PARADOTERO.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hxugF8Qujyo9b5AryK5kbsYHa1GBJvA_
"""

import numpy as np
import keras
from keras.datasets import cifar100
from keras.models import Sequential
from keras.layers import Dense, Dropout, Activation, Flatten,BatchNormalization
from keras.layers import Convolution2D, MaxPooling2D,AveragePooling2D
from keras.utils import to_categorical
from keras.utils import np_utils
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt
import tensorflow as tf

#For CIFAR100 coarse labels = superclass,Fine labels= subclass

(X_train_full, y_train_full), (X_test, y_test) = cifar100.load_data('fine')
# Take only indexes that we are interested in
indices_train = np.where( (y_train_full == 84) | (y_train_full == 5) | (y_train_full == 20)|(y_train_full == 25)|(y_train_full == 94)|(y_train_full == 6)|(y_train_full == 7)|(y_train_full == 14)|(y_train_full == 18)|(y_train_full == 24))[0]
indices_test = np.where((y_test == 84) | (y_test == 5) | (y_test == 20)|(y_test == 25)|(y_test == 94)|(y_test == 6)|(y_test == 7)|(y_test == 14)|(y_test == 18)|(y_test == 24))[0]
# Hold 10 subclass labels
y_train_full = np.array(y_train_full[indices_train])
y_test = np.array(y_test[indices_test])
# Hold 10 subclass train- and test-data
X_train_full = X_train_full[indices_train]
X_test = X_test[indices_test]

# Prepare one-hot encoding
y_train_full[np.array(y_train_full==84)]=0 #table
y_train_full[np.array(y_train_full==5)]=1  #bed
y_train_full[np.array(y_train_full==20)]=2 #chair
y_train_full[np.array(y_train_full==25)]=3  #couch
y_train_full[np.array(y_train_full==94)]=4  #wardrobe
y_train_full[np.array(y_train_full==6)]=5  #bee
y_train_full[np.array(y_train_full==7)]=6  #beetle
y_train_full[np.array(y_train_full==14)]=7 #butterfly
y_train_full[np.array(y_train_full==18)]=8 #caterpillar
y_train_full[np.array(y_train_full==24)]=9 #cockroach

y_test[np.array(y_test==84)]=0
y_test[np.array(y_test==5)]=1 
y_test[np.array(y_test==20)]=2
y_test[np.array(y_test==25)]=3 
y_test[np.array(y_test==94)]=4
y_test[np.array(y_test==6)]=5 
y_test[np.array(y_test==7)]=6
y_test[np.array(y_test==14)]=7 
y_test[np.array(y_test==18)]=8
y_test[np.array(y_test==24)]=9 

# Convert class labels to one-hot labels
y_train_full = to_categorical(y_train_full, 10)
y_test = to_categorical(y_test, 10)

#from sklearn.preprocessing import MinMaxScaler

# train,test to float type
X_train_full = X_train_full.astype('float32')
X_test = X_test.astype('float32')

# Normalize to [0,1]
X_train_full /= 255
X_test /= 255

# Split train set for validation
X_train, X_validation, y_train, y_validation = train_test_split(X_train_full, y_train_full, test_size=0.20,stratify=y_train_full)

# Data augmentation
from keras.preprocessing.image import ImageDataGenerator
datagen = ImageDataGenerator(
    rotation_range=10,
    width_shift_range=0.1,
    height_shift_range=0.1,
    zoom_range=0.2,
    horizontal_flip=True,
    )
datagen.fit(X_train)

# CNN MODEL STRUCTURE FOR FINE CLASSES

model = Sequential()
# Add first cnn layer with batch normalization and activation elu
#lecun_uniform
model.add(Convolution2D(filters=32,kernel_size=3,data_format="channels_last",input_shape=(32, 32, 3),strides=1,padding="valid",kernel_initializer="lecun_uniform",name="conv1", use_bias=False))
#model.add(Convolution2D(filters=32,kernel_size=3,strides=1,padding="valid",kernel_initializer="lecun_uniform",name="convadd", use_bias=False))

model.add(BatchNormalization())
model.add(Activation("elu"))

# Add first max-pooling
model.add(MaxPooling2D(pool_size=2,name="pool1"))

# Add first dropout
#model.add(Dropout(rate=0.2,name="h1_drop"))
# Add second cnn layer with batch normalization and activation elu
model.add(Convolution2D(filters=32,kernel_size=3,strides=1,padding="valid",kernel_initializer="lecun_uniform",name="conv2", use_bias=False))
model.add(BatchNormalization())
model.add(Activation("elu"))
model.add(MaxPooling2D(pool_size=2,name="pool2"))
model.add(Dropout(rate=0.2,name="drop1"))

# Add third cnn layer with batch normalization and activation elu
model.add(Convolution2D(filters=64,kernel_size=3,strides=1,padding="valid",kernel_initializer="lecun_uniform",name="conv3",use_bias=False))
model.add(BatchNormalization())
model.add(Activation("elu"))
model.add(AveragePooling2D(pool_size=2,name="pool3"))
#model.add(Dropout(rate=0.2,name="drop2"))

# flatten layer
model.add(Flatten())
# Add fully connected dense layer
model.add(Dense(units=512,activation='elu',name="dense1"))
#model.add(Dropout(rate=0.1,name="drop3"))
# Add fully connected output layer
model.add(Dense(units=10,activation='softmax',name="output"))

model.summary()

# COMPILE MODEL AND GET RESULTS
from keras.optimizers import Adam,SGD
from keras.callbacks import EarlyStopping, ModelCheckpoint,ReduceLROnPlateau,CSVLogger,LearningRateScheduler
import keras.backend as K

import time

class TimeHistory(keras.callbacks.Callback):
  def on_train_begin(self, logs={}):
    self.start_time = time.time()
  def on_train_end(self, logs={}):
    self.result=(time.time()-self.start_time)
    print("Training time= ",self.result)
     
time_history  = TimeHistory()

# Define optimizer
#opt_rms = keras.optimizers.rmsprop(lr=0.001,decay=1e-6)
optim = keras.optimizers.Adam(lr=0.0001,decay=1e-6)
#optim = keras.optimizers.SGD (lr=0.001,decay=1e-6,momentum=0.9,nesterov=True)
batch_size=100
# isws thelei loss='mean_squared_error'  loss='categorical_crossentropy'
model.compile(loss='mean_squared_error', optimizer=optim , metrics=['accuracy'])

# Define callbacks
checkpoint_callback = ModelCheckpoint('model_best.h5', monitor='val_loss', verbose=1, save_best_only=True, mode='min')
early_stopping_callback = EarlyStopping(monitor='loss', min_delta=0.0005, patience=7, verbose=1, mode='auto')
reduce_plateau = ReduceLROnPlateau(monitor='val_loss', factor=0.5, patience=3, verbose=1, mode='auto', min_delta=0.05, cooldown=0, min_lr=1e-10)
csv_logger = CSVLogger('training.log')

#disabled finally
def step_decay(epoch):
  initial_lrate = 0.1
  drop = 0.5
  epochs_drop = 10.0
  lr = initial_lrate * math.pow(drop,  
           math.floor((1+epoch)/epochs_drop))
  return lr

# Define custom callback
class lr_history(keras.callbacks.Callback):
    def on_train_begin(self, logs={}):
      self.lr = []
    def on_epoch_begin(self, batch, logs={}):
      self.lr.append(K.eval(self.model.optimizer.lr))
      #print(K.eval(self.model.optimizer.lr))

#lr = LearningRateScheduler(step_decay)
learn_history =lr_history()
cb =[early_stopping_callback,checkpoint_callback,reduce_plateau,csv_logger,learn_history,time_history]

results = model.fit_generator(datagen.flow(X_train, y_train,batch_size=batch_size),\
                    steps_per_epoch=2000,epochs=15,\
                    verbose=1,validation_data=(X_validation,y_validation),callbacks = cb,shuffle=True)

#Save model to disk
model_fine_json = model.to_json()
with open('model_fine.json', 'w') as json_file:
    json_file.write(model_fine_json)
model.save_weights('model_fine.h5') 
 
# Test accuracy in test set
scores = model.evaluate(X_test, y_test,batch_size=batch_size, verbose=1)

print('\nTest result: %.3f loss: %.3f' % (scores[1]*100,scores[0]))

# Plot training and validation accuracy per epoch
plt.plot(results.epoch,results.history['val_acc'],'-o',label='validation')
plt.plot(results.epoch,results.history['acc'],'-o',label='training')
plt.legend()
plt.xlabel('epochs')
plt.ylabel('accuracy')
plt.grid(True)
plt.show()


# Plot training and validation lr per epoch
plt.plot(results.epoch,learn_history.lr,'-o',label='learing rate')

plt.legend()
plt.xlabel('epochs')
plt.ylabel('Learning rate')
plt.grid(True)
plt.show()

# Plot training loss and validation loss per epoch
plt.plot(results.epoch,results.history['val_loss'],'-o',label='validation loss')
plt.plot(results.epoch,results.history['loss'],'-o',label='training loss')
plt.legend()
plt.xlabel('epochs')
plt.ylabel('loss mse')
plt.grid(True)
plt.show()

learn_history
print((time_history.result))

!cat training.log

from sklearn.metrics import confusion_matrix, accuracy_score

cifar_classes = ["table", "bed","chair", "couch","wardrobe", "bee","beetle", "butterfly","caterpillar", "cockroach"]

y_pred = model.predict(X_test, batch_size=batch_size)

#print(y_test.shape)
y_pred2 = np.argmax(y_pred,axis=1)
#print(y_pred.shape)
#y_test2=y_test
y_test2 = np.argmax(y_test,axis=1)
accuracy = (len(y_test2) - np.count_nonzero(y_pred2 - y_test2))/len(y_test2)
print(accuracy)

plt.figure(figsize=(7, 6))
plt.title('Confusion matrix', fontsize=16)
plt.imshow(confusion_matrix(y_test2,y_pred2))
plt.xticks(np.arange(10), cifar_classes, rotation=45, fontsize=12)
plt.yticks(np.arange(10), cifar_classes, fontsize=12)
plt.colorbar()
plt.show()
#print("Test accuracy:", accuracy_score(y_test, y_pred))

cm =confusion_matrix(y_test2,y_pred2)
print(cm)
acc_per_label = cm.diagonal()/cm.sum(axis=1)
acc_per_label_final = [cifar_classes[i]+ " = "+str(acc_per_label[i]) for i in range(0,10)]
print(acc_per_label_final)